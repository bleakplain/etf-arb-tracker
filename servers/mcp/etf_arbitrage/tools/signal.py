"""
Signal management tools for ETF Arbitrage MCP Server.

Provides tools for querying historical trading signals and signal details.
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
from mcp.server.fastmcp import FastMCP

from ..models.requests import (
    ListSignalsRequest,
    GetSignalRequest,
)
from ..models.enums import ResponseFormat
from ..utils.formatters import SignalFormatter, PaginationFormatter, format_timestamp
from ..utils.errors import get_error_response
from .base import (
    get_backend,
    ToolResponse,
)


def register_signal_tools(mcp: FastMCP):
    """Register all signal management tools with the MCP server.

    Args:
        mcp: FastMCP server instance
    """

    @mcp.tool(
        name="etf_arbitrage_list_signals",
        annotations={
            "title": "List Trading Signals",
            "readOnlyHint": True,
            "destructiveHint": False,
            "idempotentHint": True,
            "openWorldHint": True,
        }
    )
    async def list_signals(params: ListSignalsRequest) -> str:
        """List historical trading signals with filtering and pagination.

        This tool retrieves historical arbitrage signals generated by the system.
        Signals are created when limit-up stocks are detected and related ETFs
        are identified. It does NOT create or modify signals, only retrieves
        existing signal records.

        Args:
            params (ListSignalsRequest): Validated input parameters containing:
                - start_date (Optional[str]): Start date in YYYY-MM-DD format (e.g., '2024-01-01')
                - end_date (Optional[str]): End date in YYYY-MM-DD format (e.g., '2024-12-31')
                - stock_code (Optional[str]): Filter by stock code (6 digits)
                - limit (int): Maximum results to return (1-100, default=20)
                - offset (int): Number of results to skip for pagination (default=0)
                - response_format (ResponseFormat): Output format ('markdown' or 'json', default='markdown')

        Returns:
            str: Formatted response containing trading signals with pagination info

        Examples:
            - Use when: "Show me recent trading signals" -> params with default values
            - Use when: "List signals for stock 600519 from last week" -> params with stock_code='600519', start_date='2024-01-15'
            - Don't use when: You need to generate new signals (use monitoring tools instead)
            - Don't use when: You need details of a specific signal (use etf_arbitrage_get_signal instead)

        Error Handling:
            - Returns empty list if no signals found matching criteria
            - Returns formatted list with pagination metadata
            - Validates date format (YYYY-MM-DD)
        """
        try:
            backend = get_backend()
            signal_repo = backend.get_signal_repository()

            # Parse date filters
            start_dt = None
            end_dt = None

            if params.start_date:
                try:
                    start_dt = datetime.strptime(params.start_date, "%Y-%m-%d")
                except ValueError:
                    return ToolResponse.error("Invalid start_date format", "Use YYYY-MM-DD format (e.g., '2024-01-01')")

            if params.end_date:
                try:
                    end_dt = datetime.strptime(params.end_date, "%Y-%m-%d")
                    # Include end of day
                    end_dt = end_dt.replace(hour=23, minute=59, second=59)
                except ValueError:
                    return ToolResponse.error("Invalid end_date format", "Use YYYY-MM-DD format (e.g., '2024-12-31')")

            # Validate date range
            if start_dt and end_dt and start_dt > end_dt:
                return get_error_response(
                    "invalid_date_range",
                    start=params.start_date,
                    end=params.end_date
                )

            # Fetch signals with filters using synchronous methods
            if params.stock_code:
                signals = signal_repo.get_signals_by_stock(params.stock_code, limit=params.limit)
                total = len(signals)
            elif start_dt or end_dt:
                start_str = start_dt.strftime("%Y-%m-%d") if start_dt else "2024-01-01"
                end_str = end_dt.strftime("%Y-%m-%d") if end_dt else datetime.now().strftime("%Y-%m-%d")
                signals = signal_repo.get_signals_by_date_range(start_str, end_str)
                # Apply pagination
                total = len(signals)
                signals = signals[params.offset:params.offset + params.limit]
            else:
                signals = signal_repo.get_recent_signals(limit=params.limit)
                total = signal_repo.get_count()

            if not signals:
                return "# Trading Signals\n\nNo signals found matching the specified criteria."

            # Convert to dict format
            signal_dicts = []
            for s in signals:
                signal_dicts.append({
                    'id': s.signal_id,
                    'stock_code': s.stock_code,
                    'stock_name': s.stock_name,
                    'etf_code': s.etf_code,
                    'etf_name': s.etf_name,
                    'weight': s.etf_weight,
                    'event_type': 'limit_up',  # Default event type
                    'confidence': s.confidence,
                    'timestamp': s.timestamp,
                    'created_at': s.timestamp,  # Use timestamp as created_at
                })

            # Build response
            if params.response_format == ResponseFormat.JSON:
                import json
                response = {
                    'signals': signal_dicts,
                    'pagination': {
                        'total': total,
                        'count': len(signal_dicts),
                        'offset': params.offset,
                        'has_more': params.offset + len(signal_dicts) < total,
                        'next_offset': params.offset + len(signal_dicts) if params.offset + len(signal_dicts) < total else None,
                    }
                }
                return json.dumps(response, indent=2, ensure_ascii=False, default=str)

            # Markdown format
            lines = ["# Trading Signals", ""]

            # Add filter info
            filter_info = []
            if params.stock_code:
                filter_info.append(f"stock={params.stock_code}")
            if params.start_date:
                filter_info.append(f"from={params.start_date}")
            if params.end_date:
                filter_info.append(f"to={params.end_date}")

            if filter_info:
                lines.append(f"**Filters**: {', '.join(filter_info)}")
                lines.append("")

            lines.append(f"Found {total} signals (showing {len(signal_dicts)})")
            lines.append("")

            for s in signal_dicts:
                ts = format_timestamp(s['timestamp'] or s['created_at'])
                lines.append(f"## Signal {s['id'][:8]}")
                lines.append(f"- **Stock**: {s['stock_name']} ({s['stock_code']})")
                lines.append(f"- **ETF**: {s['etf_name']} ({s['etf_code']})")
                lines.append(f"- **Weight**: {s['weight']*100:.2f}%")
                lines.append(f"- **Event**: {s['event_type']}")
                lines.append(f"- **Confidence**: {s['confidence']*100:.1f}%")
                lines.append(f"- **Time**: {ts}")
                lines.append("")

            # Add pagination info
            pagination_meta = {
                'total': total,
                'count': len(signal_dicts),
                'offset': params.offset,
                'has_more': params.offset + len(signal_dicts) < total,
                'next_offset': params.offset + len(signal_dicts) if params.offset + len(signal_dicts) < total else None,
            }
            lines.append(PaginationFormatter.format_pagination(pagination_meta, 'markdown'))

            return "\n".join(lines)

        except Exception as e:
            return ToolResponse.error(f"Failed to list signals: {str(e)}")

    @mcp.tool(
        name="etf_arbitrage_get_signal",
        annotations={
            "title": "Get Signal Details",
            "readOnlyHint": True,
            "destructiveHint": False,
            "idempotentHint": True,
            "openWorldHint": True,
        }
    )
    async def get_signal(params: GetSignalRequest) -> str:
        """Get detailed information about a specific trading signal.

        This tool retrieves complete details of a single trading signal,
        including the stock, ETF, weight, and timing information. It does NOT
        create or modify signals, only retrieves existing signal data.

        Args:
            params (GetSignalRequest): Validated input parameters containing:
                - signal_id (str): Signal ID (UUID format)
                - response_format (ResponseFormat): Output format ('markdown' or 'json', default='markdown')

        Returns:
            str: Formatted response containing signal details

        Examples:
            - Use when: "Get details for signal abc123" -> params with signal_id='abc123-def456-...'
            - Use when: "Show full information about this signal" -> params with signal_id
            - Don't use when: You need to list multiple signals (use etf_arbitrage_list_signals instead)
            - Don't use when: You need to create a new signal (signals are auto-generated)

        Error Handling:
            - Returns error if signal_id not found
            - Returns complete signal details with all available fields
        """
        try:
            backend = get_backend()
            signal_repo = backend.get_signal_repository()

            # Fetch signal by ID
            signal = signal_repo.get_signal(params.signal_id)

            if not signal:
                return get_error_response("signal_not_found", signal_id=params.signal_id)

            # Convert to dict format
            signal_dict = {
                'id': signal.signal_id,
                'stock_code': signal.stock_code,
                'stock_name': signal.stock_name,
                'etf_code': signal.etf_code,
                'etf_name': signal.etf_name,
                'weight': signal.etf_weight,
                'weight_pct': signal.etf_weight * 100,
                'event_type': 'limit_up',
                'confidence': signal.confidence,
                'confidence_pct': float(signal.confidence) * 100 if signal.confidence else 0,
                'timestamp': signal.timestamp,
                'created_at': signal.timestamp,
                'metadata': {},
            }

            # Build response
            if params.response_format == ResponseFormat.JSON:
                import json
                return json.dumps(signal_dict, indent=2, ensure_ascii=False, default=str)

            # Markdown format
            ts = format_timestamp(signal_dict['timestamp'] or signal_dict['created_at'])

            lines = [
                f"# Signal Details",
                "",
                f"## Signal {signal_dict['id']}",
                "",
                "### Stock Information",
                f"- **Code**: {signal_dict['stock_code']}",
                f"- **Name**: {signal_dict['stock_name']}",
                "",
                "### ETF Information",
                f"- **Code**: {signal_dict['etf_code']}",
                f"- **Name**: {signal_dict['etf_name']}",
                f"- **Weight**: {signal_dict['weight_pct']:.2f}%",
                "",
                "### Signal Details",
                f"- **Event Type**: {signal_dict['event_type']}",
                f"- **Confidence**: {signal_dict['confidence_pct']:.1f}%",
                f"- **Generated**: {ts}",
                "",
            ]

            if signal_dict.get('metadata'):
                lines.append("### Additional Metadata")
                for key, value in signal_dict['metadata'].items():
                    lines.append(f"- **{key}**: {value}")

            return "\n".join(lines)

        except Exception as e:
            return ToolResponse.error(f"Failed to get signal: {str(e)}")
